      DOUBLE PRECISION FUNCTION D1MACH(I)
C-----------------------------------------------------------------------------
C  DOUBLE-PRECISION MACHINE CONSTANTS.  See 'Revisions' below.
C
C  D1MACH( 1) = B**(EMIN-1), THE SMALLEST POSITIVE MAGNITUDE.
C  D1MACH( 2) = B**EMAX*(1 - B**(-T)), THE LARGEST MAGNITUDE.
C  D1MACH( 3) = B**(-T), THE SMALLEST RELATIVE SPACING.
C  D1MACH( 4) = B**(1-T), THE LARGEST RELATIVE SPACING.
C  D1MACH( 5) = LOG10(B)
C
C  TO ALTER THIS FUNCTION FOR A PARTICULAR ENVIRONMENT,
C  THE DESIRED SET OF DATA STATEMENTS SHOULD BE ACTIVATED BY
C  REMOVING THE C FROM COLUMN 1.
C  ON RARE MACHINES A STATIC STATEMENT MAY NEED TO BE ADDED.
C  (BUT PROBABLY MORE SYSTEMS PROHIBIT IT THAN REQUIRE IT.)
C
C  FOR IEEE-ARITHMETIC MACHINES (BINARY STANDARD), ONE OF THE FIRST
C  TWO SETS OF CONSTANTS BELOW SHOULD BE APPROPRIATE.  IF YOU DO NOT
C  KNOW WHICH SET TO USE, TRY BOTH AND SEE WHICH GIVES PLAUSIBLE
C  VALUES.
C
C  WHERE POSSIBLE, DECIMAL, OCTAL OR HEXADECIMAL CONSTANTS ARE USED
C  TO SPECIFY THE CONSTANTS EXACTLY.  SOMETIMES THIS REQUIRES USING
C  EQUIVALENT INTEGER ARRAYS.  IF YOUR COMPILER USES HALF-WORD
C  INTEGERS BY DEFAULT (SOMETIMES CALLED INTEGER*2), YOU MAY NEED TO
C  CHANGE INTEGER TO INTEGER*4 OR OTHERWISE INSTRUCT YOUR COMPILER
C  TO USE FULL-WORD INTEGERS IN THE NEXT 5 DECLARATIONS.
C
C  COMMENTS JUST BEFORE THE END STATEMENT (LINES STARTING WITH *)
C  GIVE C SOURCE FOR D1MACH.
C
C  REVISIONS:
c    This is the almost identical to the standard 'd1mach.f' that
c    works by specifying constants (called 'd1mach_const.f' in Streamer).
c    The only difference is that the IF test and associated error
c    message call have been commented out for Linux.  For some reason,
c    it fails the test.  However, the Streamer results do not appear
c    to be affected.
C-----------------------------------------------------------------------------
      INTEGER SMALL(4), LARGE(4), RIGHT(4), DIVER(4), LOG10(4), SC
      DOUBLE PRECISION DMACH(5), EPS, EPSNEW, S

      EQUIVALENCE (DMACH(1),SMALL(1)), (DMACH(2),LARGE(1)),
     $            (DMACH(3),RIGHT(1)), (DMACH(4),DIVER(1)),
     $            (DMACH(5),LOG10(1))

      LOGICAL  PASS1
      SAVE     PASS1
      DATA     PASS1 /.TRUE./

C IEEE ARITHMETIC MACHINES, SUCH AS THE Sun Sparc, SGI, AT&T 3B SERIES AND
C MOTOROLA 68000 BASED MACHINES (E.G. SUN 3 AND AT&T PC 7300),
C IN WHICH THE MOST SIGNIFICANT BYTE IS STORED FIRST.

C      DATA (SMALL(N),N=1,2)/1048576,0/, (LARGE(N),N=1,2)/2146435071,-1/,
C     $  (RIGHT(N),N=1,2)/1017118720,0/, (DIVER(N),N=1,2)/1018167296,0/,
C     $  (LOG10(N),N=1,2)/1070810131,1352628735/, SC/987/

C PCs WITH INTEL PROCESSORS. (AGREES WITH MICROSOFT FORTRAN POWERSTATION.)  
C IEEE ARITHMETIC MACHINES IN WHICH THE LEAST SIGNIFICANT BYTE IS STORED FIRST.

      DATA (SMALL(N),N=1,2)/0,1048576/, (LARGE(N),N=1,2)/-1,2146435071/,
     $  (RIGHT(N),N=1,2)/0,1017118720/, (DIVER(N),N=1,2)/0,1018167296/,
     $  (LOG10(N),N=1,2)/1352628735,1070810131/, SC/987/

C DEC ALPHA g-floating version, VMS (added 6/4/94 by stone)

c      DATA (SMALL(N),N=1,2) /16,0/
c      data (LARGE(N),N=1,2) /-32769,-1/
c      data (RIGHT(N),N=1,2) /15552,0/
c      data (DIVER(N),N=1,2) /15568,0/
c      data (LOG10(N),N=1,2) /1142112243,2046775455/
c      data sc /987/

C AMDAHL MACHINES.

C      DATA (SMALL(N),N=1,2)/1048576,0/, (LARGE(N),N=1,2)/2147483647,-1/,
C     $ (RIGHT(N),N=1,2)/856686592,0/, (DIVER(N),N=1,2)/ 873463808,0/,
C     $ (LOG10(N),N=1,2)/1091781651,1352628735/, SC/987/

C CRAY 1, XMP, 2, AND 3.

C      DATA
C     $ (SMALL(N),N=1,2)/201354000000000000000B,000000000000000000000B/,
C     $ (LARGE(N),N=1,2)/577767777777777777777B,000007777777777777776B/,
C     $ (RIGHT(N),N=1,2)/376434000000000000000B,000000000000000000000B/,
C     $ (DIVER(N),N=1,2)/376444000000000000000B,000000000000000000000B/,
C     $ (LOG10(N),N=1,2)/377774642023241175717B,000007571421742254654B/,
C     $ SC/987/

C DATA GENERAL ECLIPSE S/200
C NOTE - IT MAY BE APPROPRIATE TO INCLUDE THE FOLLOWING LINE -
C STATIC DMACH(5)

C      DATA SMALL/20K,3*0/, LARGE/77777K,3*177777K/,
C     $  RIGHT/31420K,3*0/, DIVER/32020K,3*0/,
C     $  LOG10/40423K,42023K,50237K,74776K/, SC/987/

C IBM 360/370 SERIES, XEROX SIGMA 5/7/9 AND THE SEL SYSTEMS 85/86.

C      DATA (SMALL(N),N=1,2)/Z00100000,Z00000000/,
C     $  (LARGE(N),N=1,2)/Z7FFFFFFF,ZFFFFFFFF/,
C     $  (RIGHT(N),N=1,2)/Z33100000,Z00000000/,
C     $  (DIVER(N),N=1,2)/Z34100000,Z00000000/,
C     $  (LOG10(N),N=1,2)/Z41134413,Z509F79FF/, SC/987/

C INTERDATA 8/32 WITH THE UNIX SYSTEM FORTRAN 77 COMPILER.
C FOR THE INTERDATA FORTRAN VII COMPILER REPLACE
C THE Z'S SPECIFYING HEX CONSTANTS WITH Y'S.

C      DATA (SMALL(N),N=1,2)/Z'00100000',Z'00000000'/,
C     $  (LARGE(N),N=1,2)/Z'7EFFFFFF',Z'FFFFFFFF'/,
C     $  (RIGHT(N),N=1,2)/Z'33100000',Z'00000000'/,
C     $  (DIVER(N),N=1,2)/Z'34100000',Z'00000000'/,
C     $  (LOG10(N),N=1,2)/Z'41134413',Z'509F79FF'/, SC/987/

C VAX UNIX F77 COMPILER

C      DATA (SMALL(N),N=1,2)/128,0/, (LARGE(N),N=1,2)/-32769,-1/,
C     $  (RIGHT(N),N=1,2)/9344,0/, (DIVER(N),N=1,2)/9472,0/,
C     $  (LOG10(N),N=1,2)/546979738,-805796613/, SC/987/

C VAX-11 WITH FORTRAN IV-PLUS COMPILER

C      DATA (SMALL(N),N=1,2)/Z00000080,Z00000000/,
C     $  (LARGE(N),N=1,2)/ZFFFF7FFF,ZFFFFFFFF/,
C     $  (RIGHT(N),N=1,2)/Z00002480,Z00000000/,
C     $  (DIVER(N),N=1,2)/Z00002500,Z00000000/,
C     $  (LOG10(N),N=1,2)/Z209A3F9A,ZCFF884FB/, SC/987/

C VAX/VMS VERSION 2.2

C      DATA (SMALL(N),N=1,2)/'80'X,'0'X/,
C     $  (LARGE(N),N=1,2)/'FFFF7FFF'X,'FFFFFFFF'X/,
C     $  (RIGHT(N),N=1,2)/'2480'X,'0'X/, (DIVER(N),N=1,2)/'2500'X,'0'X/,
C     $  (LOG10(N),N=1,2)/'209A3F9A'X,'CFF884FB'X/, SC/987/
C---------------------------------------------------------------------------

      IF( PASS1 )  THEN

         PASS1 = .FALSE.
         IF (SC.NE.987)
     $       CALL ERRMSG( 'D1MACH--NO DATA STATEMENTS ACTIVE',.TRUE.)

C                        ** CALCULATE MACHINE PRECISION
         EPSNEW = 0.01D0
   10    EPS = EPSNEW
            EPSNEW = EPSNEW / 1.1D0
C                               ** IMPORTANT TO STORE 'S' SINCE MAY BE
C                               ** KEPT IN HIGHER PRECISION IN REGISTERS
            S = 1.D0 + EPSNEW
            IF( S.GT.1.D0 ) GO TO 10
C         IF( EPS/DMACH(4).LT.0.5D0 .OR. EPS/DMACH(4).GT.2.D0 )
C     $       CALL ERRMSG( 'D1MACH--TABULATED PRECISION WRONG',.TRUE.)
      END IF

      IF (I .LT. 1 .OR. I .GT. 5)
     $    CALL ERRMSG( 'D1MACH--ARGUMENT OUT OF BOUNDS',.TRUE.)
      D1MACH = DMACH(I)

      RETURN
      END

c************************* ERROR MESSAGES *********************************

        SUBROUTINE  ERRMSG( MESSAG, FATAL )
        IMPLICIT DOUBLE PRECISION ( A-H, O-Z )
C
C        PRINT OUT A WARNING OR ERROR MESSAGE;  ABORT IF ERROR
C
        LOGICAL       FATAL, ONCE
        CHARACTER*(*) MESSAG
        INTEGER       MAXMSG, NUMMSG
        SAVE          MAXMSG, NUMMSG, ONCE
        DATA NUMMSG / 0 /,  MAXMSG / 100 /,  ONCE / .FALSE. /
C
C
        IF ( FATAL )  THEN
           WRITE ( *, '(2A)' )  ' ERROR >>> ', MESSAG
           STOP
        END IF
C
        NUMMSG = NUMMSG + 1
        IF ( NUMMSG.GT.MAXMSG )  THEN
           IF ( .NOT.ONCE )  WRITE ( *,99 )
           ONCE = .TRUE.
        ELSE
           WRITE ( *, '(2A)' )  ' WARNING >>> ', MESSAG
        ENDIF
C
        RETURN
C
   99 FORMAT( ///,' >>> TOO MANY WARNING MESSAGES --  ',
     $   'THEY WILL NO LONGER BE PRINTED  <<<', /// )
        END


